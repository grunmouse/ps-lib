(unicode-dict.ps) stealfile
(traverse.ps) stealfile

/unicode-name unicode invert def

%Расшифровывает байт кодировки utf8, выделяя количество ведущих единиц
% и значение смысловой части
%[int]
/utf8byte{
	0
	{
		%[int, count]
		1 7 2 index	sub bitshift
		%[int, count, mask]
		2 index and
		%[int, count, int and mask]
		0 eq
		{
			%[int, count]
			exit
		} if
		%[int, count]
		dup 4 eq
		{
			exit
		}if
		1 add
		
	} loop
	%[int, count]
	exch 
	1 7 3 index sub
	%[count, int, 1, 7 - count]
	
	bitshift 1 sub
	%[count, int, mask]
	and
	exch
	%[value, count]
} def
%[value, count]

%Преобразовывает utf8-строку в массив кодовых точек utf
%[str]
/utf8points {
	[
		exch
		{
			%[prev, byte]
			utf8byte
			%[prev, value, count]
			1 eq
			{
				%then
				%[prev, value]
				exch
				6 bitshift
				or
				%[{prev|value}]
			}
			{
				%else
				%[prev, value]
			}
			ifelse
		}
		forall
	]
} def
%[array]

% codePoints - массив кодовых точек преобразуемой строки
% encoding - словарь, оторбражающий номер кодовой точки на значение байта однобайтовой кодировки
%[codePoints, encoding]
/utfToOneByte {
	0 dict begin{
		/encoding exch def
		/arr exch def
		[
			arr
			{
				encoding exch
				intcvn
				safeGet
			}
			forall
		]
	}
} def



%Принимает на вход массив имён символов и словарь юникода
%возвращает массив номеров юникодных точек
%[arr]
/unicode-encoding {
	0 dict begin 
		/source exch def
		/len source length def
		/arr len array def
		/dic len dict def
		
		source
		{
			%[proc, source, value, key]
			exch
			%[index, name]
			unicode exch get
			%[index, codepoint]
			
			2 copy
			arr 3 1 roll put
			
			%[index, codepoint]
			intcvn
			%[index, /codepoint]
			exch
			dic 3 1 roll put
			%[]
			
			%[proc, source]
		}
		forallpairs
		
		arr dic
	end
} def